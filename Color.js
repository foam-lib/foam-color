export const GAMMA = 2.2;

export const HexAliceBlue = '#F0F8FF';
export const HexAntiqueWhite = '#FAEBD7';
export const HexAqua = '#00FFFF';
export const HexAquamarine = '#7FFFD4';
export const HexAzure = '#F0FFFF';
export const HexBeige = '#F5F5DC';
export const HexBisque = '#FFE4C4';
export const HexBlack = '#000000';
export const HexBlanchedAlmond = '#FFEBCD';
export const HexBlue = '#0000FF';
export const HexBlueViolet = '#8A2BE2';
export const HexBrown = '#A52A2A';
export const HexBurlyWood = '#DEB887';
export const HexCadetBlue = '#5F9EA0';
export const HexChartreuse = '#7FFF00';
export const HexChocolate = '#D2691E';
export const HexCoral = '#FF7F50';
export const HexCornflowerBlue = '#6495ED';
export const HexCornsilk = '#FFF8DC';
export const HexCrimson = '#DC143C';
export const HexCyan = '#00FFFF';
export const HexDarkBlue = '#00008B';
export const HexDarkCyan = '#008B8B';
export const HexDarkGoldenRod = '#B8860B';
export const HexDarkGray = '#A9A9A9';
export const HexDarkGrey = '#A9A9A9';
export const HexDarkGreen = '#006400';
export const HexDarkKhaki = '#BDB76B';
export const HexDarkMagenta = '#8B008B';
export const HexDarkOliveGreen = '#556B2F';
export const HexDarkorange = '#FF8C00';
export const HexDarkOrchid = '#9932CC';
export const HexDarkRed = '#8B0000';
export const HexDarkSalmon = '#E9967A';
export const HexDarkSeaGreen = '#8FBC8F';
export const HexDarkSlateBlue = '#483D8B';
export const HexDarkSlateGray = '#2F4F4F';
export const HexDarkSlateGrey = '#2F4F4F';
export const HexDarkTurquoise = '#00CED1';
export const HexDarkViolet = '#9400D3';
export const HexDeepPink = '#FF1493';
export const HexDeepSkyBlue = '#00BFFF';
export const HexDimGray = '#696969';
export const HexDimGrey = '#696969';
export const HexDodgerBlue = '#1E90FF';
export const HexFireBrick = '#B22222';
export const HexFloralWhite = '#FFFAF0';
export const HexForestGreen = '#228B22';
export const HexFuchsia = '#FF00FF';
export const HexGainsboro = '#DCDCDC';
export const HexGhostWhite = '#F8F8FF';
export const HexGold = '#FFD700';
export const HexGoldenRod = '#DAA520';
export const HexGray = '#808080';
export const HexGrey = '#808080';
export const HexGreen = '#008000';
export const HexGreenYellow = '#ADFF2F';
export const HexHoneyDew = '#F0FFF0';
export const HexHotPink = '#FF69B4';
export const HexIndianRed = '#CD5C5C';
export const HexIndigo = '#4B0082';
export const HexIvory = '#FFFFF0';
export const HexKhaki = '#F0E68C';
export const HexLavender = '#E6E6FA';
export const HexLavenderBlush = '#FFF0F5';
export const HexLawnGreen = '#7CFC00';
export const HexLemonChiffon = '#FFFACD';
export const HexLightBlue = '#ADD8E6';
export const HexLightCoral = '#F08080';
export const HexLightCyan = '#E0FFFF';
export const HexLightGoldenRodYellow = '#FAFAD2';
export const HexLightGray = '#D3D3D3';
export const HexLightGrey = '#D3D3D3';
export const HexLightGreen = '#90EE90';
export const HexLightPink = '#FFB6C1';
export const HexLightSalmon = '#FFA07A';
export const HexLightSeaGreen = '#20B2AA';
export const HexLightSkyBlue = '#87CEFA';
export const HexLightSlateGray = '#778899';
export const HexLightSlateGrey = '#778899';
export const HexLightSteelBlue = '#B0C4DE';
export const HexLightYellow = '#FFFFE0';
export const HexLime = '#00FF00';
export const HexLimeGreen = '#32CD32';
export const HexLinen = '#FAF0E6';
export const HexMagenta = '#FF00FF';
export const HexMaroon = '#800000';
export const HexMediumAquaMarine = '#66CDAA';
export const HexMediumBlue = '#0000CD';
export const HexMediumOrchid = '#BA55D3';
export const HexMediumPurple = '#9370D8';
export const HexMediumSeaGreen = '#3CB371';
export const HexMediumSlateBlue = '#7B68EE';
export const HexMediumSpringGreen = '#00FA9A';
export const HexMediumTurquoise = '#48D1CC';
export const HexMediumVioletRed = '#C71585';
export const HexMidnightBlue = '#191970';
export const HexMintCream = '#F5FFFA';
export const HexMistyRose = '#FFE4E1';
export const HexMoccasin = '#FFE4B5';
export const HexNavajoWhite = '#FFDEAD';
export const HexNavy = '#000080';
export const HexOldLace = '#FDF5E6';
export const HexOlive = '#808000';
export const HexOliveDrab = '#6B8E23';
export const HexOrange = '#FFA500';
export const HexOrangeRed = '#FF4500';
export const HexOrchid = '#DA70D6';
export const HexPaleGoldenRod = '#EEE8AA';
export const HexPaleGreen = '#98FB98';
export const HexPaleTurquoise = '#AFEEEE';
export const HexPaleVioletRed = '#D87093';
export const HexPapayaWhip = '#FFEFD5';
export const HexPeachPuff = '#FFDAB9';
export const HexPeru = '#CD853F';
export const HexPink = '#FFC0CB';
export const HexPlum = '#DDA0DD';
export const HexPowderBlue = '#B0E0E6';
export const HexPurple = '#800080';
export const HexRed = '#FF0000';
export const HexRosyBrown = '#BC8F8F';
export const HexRoyalBlue = '#4169E1';
export const HexSaddleBrown = '#8B4513';
export const HexSalmon = '#FA8072';
export const HexSandyBrown = '#F4A460';
export const HexSeaGreen = '#2E8B57';
export const HexSeaShell = '#FFF5EE';
export const HexSienna = '#A0522D';
export const HexSilver = '#C0C0C0';
export const HexSkyBlue = '#87CEEB';
export const HexSlateBlue = '#6A5ACD';
export const HexSlateGray = '#708090';
export const HexSlateGrey = '#708090';
export const HexSnow = '#FFFAFA';
export const HexSpringGreen = '#00FF7F';
export const HexSteelBlue = '#4682B4';
export const HexTan = '#D2B48C';
export const HexTeal = '#008080';
export const HexThistle = '#D8BFD8';
export const HexTomato = '#FF6347';
export const HexTurquoise = '#40E0D0';
export const HexViolet = '#EE82EE';
export const HexWheat = '#F5DEB3';
export const HexWhite = '#FFFFFF';
export const HexWhiteSmoke = '#F5F5F5';
export const HexYellow = '#FFFF00';
export const HexYellowGreen = '#9ACD32';

/**
 * Map of CSS string colors.
 * @type {{AliceBlue: string, AntiqueWhite: string, Aqua: string, Aquamarine: string, Azure: string, Beige: string, Bisque: string, Black: string, BlanchedAlmond: string, Blue: string, BlueViolet: string, Brown: string, BurlyWood: string, CadetBlue: string, Chartreuse: string, Chocolate: string, Coral: string, CornflowerBlue: string, Cornsilk: string, Crimson: string, Cyan: string, DarkBlue: string, DarkCyan: string, DarkGoldenRod: string, DarkGray: string, DarkGrey: string, DarkGreen: string, DarkKhaki: string, DarkMagenta: string, DarkOliveGreen: string, Darkorange: string, DarkOrchid: string, DarkRed: string, DarkSalmon: string, DarkSeaGreen: string, DarkSlateBlue: string, DarkSlateGray: string, DarkSlateGrey: string, DarkTurquoise: string, DarkViolet: string, DeepPink: string, DeepSkyBlue: string, DimGray: string, DimGrey: string, DodgerBlue: string, FireBrick: string, FloralWhite: string, ForestGreen: string, Fuchsia: string, Gainsboro: string, GhostWhite: string, Gold: string, GoldenRod: string, Gray: string, Grey: string, Green: string, GreenYellow: string, HoneyDew: string, HotPink: string, IndianRed: string, Indigo: string, Ivory: string, Khaki: string, Lavender: string, LavenderBlush: string, LawnGreen: string, LemonChiffon: string, LightBlue: string, LightCoral: string, LightCyan: string, LightGoldenRodYellow: string, LightGray: string, LightGrey: string, LightGreen: string, LightPink: string, LightSalmon: string, LightSeaGreen: string, LightSkyBlue: string, LightSlateGray: string, LightSlateGrey: string, LightSteelBlue: string, LightYellow: string, Lime: string, LimeGreen: string, Linen: string, Magenta: string, Maroon: string, MediumAquaMarine: string, MediumBlue: string, MediumOrchid: string, MediumPurple: string, MediumSeaGreen: string, MediumSlateBlue: string, MediumSpringGreen: string, MediumTurquoise: string, MediumVioletRed: string, MidnightBlue: string, MintCream: string, MistyRose: string, Moccasin: string, NavajoWhite: string, Navy: string, OldLace: string, Olive: string, OliveDrab: string, Orange: string, OrangeRed: string, Orchid: string, PaleGoldenRod: string, PaleGreen: string, PaleTurquoise: string, PaleVioletRed: string, PapayaWhip: string, PeachPuff: string, Peru: string, Pink: string, Plum: string, PowderBlue: string, Purple: string, Red: string, RosyBrown: string, RoyalBlue: string, SaddleBrown: string, Salmon: string, SandyBrown: string, SeaGreen: string, SeaShell: string, Sienna: string, Silver: string, SkyBlue: string, SlateBlue: string, SlateGray: string, SlateGrey: string, Snow: string, SpringGreen: string, SteelBlue: string, Tan: string, Teal: string, Thistle: string, Tomato: string, Turquoise: string, Violet: string, Wheat: string, White: string, WhiteSmoke: string, Yellow: string, YellowGreen: string}}
 */
export const CSSColorStringMap = {
    AliceBlue : HexAliceBlue,
    AntiqueWhite : HexAntiqueWhite,
    Aqua : HexAqua,
    Aquamarine : HexAquamarine,
    Azure : HexAzure,
    Beige : HexBeige,
    Bisque : HexBisque,
    Black : HexBlack,
    BlanchedAlmond : HexBlanchedAlmond,
    Blue : HexBlue,
    BlueViolet : HexBlueViolet,
    Brown : HexBrown,
    BurlyWood : HexBurlyWood,
    CadetBlue : HexCadetBlue,
    Chartreuse : HexChartreuse,
    Chocolate : HexChocolate,
    Coral : HexCoral,
    CornflowerBlue : HexCornflowerBlue,
    Cornsilk : HexCornsilk,
    Crimson : HexCrimson,
    Cyan : HexCyan,
    DarkBlue : HexDarkBlue,
    DarkCyan : HexDarkCyan,
    DarkGoldenRod : HexDarkGoldenRod,
    DarkGray : HexDarkGray,
    DarkGrey : HexDarkGrey,
    DarkGreen : HexDarkGreen,
    DarkKhaki : HexDarkKhaki,
    DarkMagenta : HexDarkMagenta,
    DarkOliveGreen : HexDarkOliveGreen,
    Darkorange : HexDarkorange,
    DarkOrchid : HexDarkOrchid,
    DarkRed : HexDarkRed,
    DarkSalmon : HexDarkSalmon,
    DarkSeaGreen : HexDarkSeaGreen,
    DarkSlateBlue : HexDarkSlateBlue,
    DarkSlateGray : HexDarkSlateGray,
    DarkSlateGrey : HexDarkSlateGrey,
    DarkTurquoise : HexDarkTurquoise,
    DarkViolet : HexDarkViolet,
    DeepPink : HexDeepPink,
    DeepSkyBlue : HexDeepSkyBlue,
    DimGray : HexDimGray,
    DimGrey : HexDimGrey,
    DodgerBlue : HexDodgerBlue,
    FireBrick : HexFireBrick,
    FloralWhite : HexFloralWhite,
    ForestGreen : HexForestGreen,
    Fuchsia : HexFuchsia,
    Gainsboro : HexGainsboro,
    GhostWhite : HexGhostWhite,
    Gold : HexGold,
    GoldenRod : HexGoldenRod,
    Gray : HexGray,
    Grey : HexGrey,
    Green : HexGreen,
    GreenYellow : HexGreenYellow,
    HoneyDew : HexHoneyDew,
    HotPink : HexHotPink,
    IndianRed : HexIndianRed,
    Indigo : HexIndigo,
    Ivory : HexIvory,
    Khaki : HexKhaki,
    Lavender : HexLavender,
    LavenderBlush : HexLavenderBlush,
    LawnGreen : HexLawnGreen,
    LemonChiffon : HexLemonChiffon,
    LightBlue : HexLightBlue,
    LightCoral : HexLightCoral,
    LightCyan : HexLightCyan,
    LightGoldenRodYellow : HexLightGoldenRodYellow,
    LightGray : HexLightGray,
    LightGrey : HexLightGrey,
    LightGreen : HexLightGreen,
    LightPink : HexLightPink,
    LightSalmon : HexLightSalmon,
    LightSeaGreen : HexLightSeaGreen,
    LightSkyBlue : HexLightSkyBlue,
    LightSlateGray : HexLightSlateGray,
    LightSlateGrey : HexLightSlateGrey,
    LightSteelBlue : HexLightSteelBlue,
    LightYellow : HexLightYellow,
    Lime : HexLime,
    LimeGreen : HexLimeGreen,
    Linen : HexLinen,
    Magenta : HexMagenta,
    Maroon : HexMaroon,
    MediumAquaMarine : HexMediumAquaMarine,
    MediumBlue : HexMediumBlue,
    MediumOrchid : HexMediumOrchid,
    MediumPurple : HexMediumPurple,
    MediumSeaGreen : HexMediumSeaGreen,
    MediumSlateBlue : HexMediumSlateBlue,
    MediumSpringGreen : HexMediumSpringGreen,
    MediumTurquoise : HexMediumTurquoise,
    MediumVioletRed : HexMediumVioletRed,
    MidnightBlue : HexMidnightBlue,
    MintCream : HexMintCream,
    MistyRose : HexMistyRose,
    Moccasin : HexMoccasin,
    NavajoWhite : HexNavajoWhite,
    Navy : HexNavy,
    OldLace : HexOldLace,
    Olive : HexOlive,
    OliveDrab : HexOliveDrab,
    Orange : HexOrange,
    OrangeRed : HexOrangeRed,
    Orchid : HexOrchid,
    PaleGoldenRod : HexPaleGoldenRod,
    PaleGreen : HexPaleGreen,
    PaleTurquoise : HexPaleTurquoise,
    PaleVioletRed : HexPaleVioletRed,
    PapayaWhip : HexPapayaWhip,
    PeachPuff : HexPeachPuff,
    Peru : HexPeru,
    Pink : HexPink,
    Plum : HexPlum,
    PowderBlue : HexPowderBlue,
    Purple : HexPurple,
    Red : HexRed,
    RosyBrown : HexRosyBrown,
    RoyalBlue : HexRoyalBlue,
    SaddleBrown : HexSaddleBrown,
    Salmon : HexSalmon,
    SandyBrown : HexSandyBrown,
    SeaGreen : HexSeaGreen,
    SeaShell : HexSeaShell,
    Sienna : HexSienna,
    Silver : HexSilver,
    SkyBlue : HexSkyBlue,
    SlateBlue : HexSlateBlue,
    SlateGray : HexSlateGray,
    SlateGrey : HexSlateGrey,
    Snow : HexSnow,
    SpringGreen : HexSpringGreen,
    SteelBlue : HexSteelBlue,
    Tan : HexTan,
    Teal : HexTeal,
    Thistle : HexThistle,
    Tomato : HexTomato,
    Turquoise : HexTurquoise,
    Violet : HexViolet,
    Wheat : HexViolet,
    White : HexWhite,
    WhiteSmoke : HexWhiteSmoke,
    Yellow : HexYellow,
    YellowGreen : HexYellowGreen
};

/*----------------------------------------------------------------------------------------------------------------*/
// internal
/*----------------------------------------------------------------------------------------------------------------*/

const _1_255 = 1 / 255;
const PI2 = Math.PI * 2;
const TEMP_ARR_0 = [];
const TEMP_VEC3_0 = [0,0,0];
const TEMP_VEC4_0 = [0,0,0,0];
const HSB_CHANGE_STEP = 0.05;

/*----------------------------------------------------------------------------------------------------------------*/
// construct
/*----------------------------------------------------------------------------------------------------------------*/

/**
 * Creates a new color representation.
 * @returns {number[]}
 */
export function create(){
    return [0,0,0,1];
}

/**
 * Creates a new white color representation.
 * @returns {number[]}
 */
export function white(){
    return [1,1,1,1];
}

/**
 * Creates a new white grey representation.
 * @param [s]
 * @returns {number[]}
 */
export function grey(s){
    s = s === undefined ? 0.5 : s;
    return [s,s,s,1];
}

/**
 * Creates a new black color representation.
 * @returns {number[]}
 */
export function black(){
    return create();
}

/**
 * Creates a new red color representation.
 * @returns {number[]}
 */
export function red(){
    return [1,0,0,1];
}

/**
 * Creates a new green color representation.
 * @returns {number[]}
 */
export function green(){
    return [0,1,0,1];
}

/**
 * Creates a new blue color representation.
 * @returns {number[]}
 */
export function blue(){
    return [0,0,1,1];
}

/**
 * Creates a new yellow color representation.
 * @returns {number[]}
 */
export function yellow(){
    return [1,1,0,1];
}

/**
 * Creates a new purple color representation.
 * @returns {number[]}
 */
export function purple(){
    return [1,0,1,1];
}

/**
 * Creates a new transparent color representation.
 * @returns {number[]}
 */
export function transparent(){
    return [0,0,0,0];
}

/*----------------------------------------------------------------------------------------------------------------*/
// set
/*----------------------------------------------------------------------------------------------------------------*/

/**
 * Sets color r,g,b,a-values from another color.
 * @param colora
 * @param colorb
 * @returns {*}
 */
export function set(colora,colorb){
    colora[0] = colorb[0];
    colora[1] = colorb[1];
    colora[2] = colorb[2];
    colora[3] = colorb[3] || 1.0;
    return colora;
}

/**
 * Sets color r,g,b,a-values individually.
 * @param color
 * @param r
 * @param g
 * @param b
 * @param a
 * @returns {*}
 */
export function set4(color,r,g,b,a){
    color[0] = r;
    color[1] = g;
    color[2] = b;
    color[3] = a || 1.0;
    return color;
}

/**
 * Sets color r,gmb-values individually.
 * @param color
 * @param r
 * @param g
 * @param b
 * @returns {*}
 */
export function set3(color,r,g,b){
    color[0] = r;
    color[1] = g;
    color[2] = b;
    return color;
}

/**
 * Sets color r,g,b-values chromatic and alpha value.
 * @param color
 * @param k
 * @param a
 * @returns {*}
 */
export function set2(color,k,a){
    color[0] = color[1] = color[2] = k;
    color[3] = a || 1.0;
    return color;
}

/**
 * Sets color r,g,b-values chromatic.
 * @param color
 * @param k
 * @returns {*}
 */
export function set1(color,k){
    color[0] = color[1] = color[2] = k;
    return color;
}

/**
 * Sets the color alpha-value individually.
 * @param color
 * @param alpha
 * @returns {*}
 */
export function setAlpha(color,alpha){
    color[3] = alpha;
    return alpha;
}

/*----------------------------------------------------------------------------------------------------------------*/
// copy
/*----------------------------------------------------------------------------------------------------------------*/

/**
 * Returns a copy of the color
 * @param color
 * @returns {*}
 */
export function copy(color){
    return set(create(),color);
}

/*----------------------------------------------------------------------------------------------------------------*/
// format & validate
/*----------------------------------------------------------------------------------------------------------------*/

/**
 * Returns true if the input is a 'rgb(r,g,b)' or 'rgba(r,g,b,a)' string color representation.
 * @param color
 * @returns {boolean}
 */
export function isRgbaString(color){
    return typeof color === 'string' && color.indexOf('rgb') === 0;
}

/**
 * Returns true if the input is hex string color representation.
 * @param color
 * @returns {boolean}
 */
export function isHex(color){
    return typeof color === 'string' && color[0] === '#';
}

/**
 * Returns true if the input is chromatic.
 * @param colorRgb
 * @returns {boolean}
 */
export function isGreyscale(colorRgb){
    return colorRgb[0] === colorRgb[1] === colorRgb[2];
}

/**
 * Converts a color from float to integer representation.
 * @param color
 * @returns {*}
 */
export function toInt(color){
    color[0] *= 255;
    color[1] *= 255;
    color[2] *= 255;
    return color;
}

/**
 * Converts a color from integer to float representation.
 * @param color
 * @returns {*}
 */
export function toFloat(color){
    color[0] *= _1_255;
    color[1] *= _1_255;
    color[2] *= _1_255;
    return color;
}

const regexRgbaStrElements = /\(([^)]+)\)/;

/**
 * Sets a colors r,g,b-values from 'rgb(r,g,b)' or 'rgba(r,g,b,a)' string color representation.
 * @param color
 * @param rgbstr_or_rgbastr
 * @returns {*}
 */
export function setFromRgbaString(color,rgbstr_or_rgbastr){
    if(!isRgbaString(rgbstr_or_rgbastr)){
        throw new Error("Input string not using 'rgb(r,g,b)' or 'rgba(r,g,b,a) format.'");
    }
    const raw = regexRgbaStrElements.exec(rgbstr_or_rgbastr);
    const elements = raw[1].split(',');
    color[0] = (+elements[0]) / 255;
    color[1] = (+elements[1]) / 255;
    color[2] = (+elements[2]) / 255;
    color[3] = elements[3] === undefined ? 1.0 : +elements[3];
    return color;
}

/**
 * Returns a 'rgba(r,g,b,a)' string color representation of the color.
 * @param colorRgba
 * @returns {*}
 */
export function getRgbaString(colorRgba){
    return getRgbaString4(colorRgba[0],colorRgba[1],colorRgba[2],colorRgba[3]);
}

export function getRgbaString4(r,g,b,a){
    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = a === undefined ? 1.0 : a;
    return !a ? `rgb(${r},${g},${b})` : `rgba(${r},${g},${b},${a})`;
}

export function getRgbaString3(r,g,b){
    return getRgbaString4(r,g,b,1.0);
}

export function getRgbaString2(k,a){
    return getRgbaString4(k,k,k,a);
}

export function getRgbaString1(k){
    return getRgbaString4(k,k,k,1.0);
}

/**
 * Creates a new color from 'rgb(r,g,b)' or 'rgba(r,g,b,a)' string color representation.
 * @param rgbstr_or_rgbastr
 * @returns {*}
 */
export function createFromRgbaString(rgbstr_or_rgbastr){
    return setFromRgbaString(create(),rgbstr_or_rgbastr);
}

//hex

/**
 * Sets a colors r,g,b-values from hex string color representation.
 * @param color
 * @param hex
 * @returns {*}
 */
export function setFromHex(color,hex){
    hex = CSSColorStringMap[hex] || CSSColorStringMap[hex.toUpperCase()] || hex;
    hex = hex.substring(1);
    hex = hex.length === 3 ? `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}` : hex;
    color[0] = parseInt(hex.substring(0, 2), 16) * _1_255;
    color[1] = parseInt(hex.substring(2, 4), 16) * _1_255;
    color[2] = parseInt(hex.substring(4, 6), 16) * _1_255;
    color[3] = 1;
    return color;
}

/**
 * Returns a hex string color representation of the float color input.
 * @param colorRgba
 * @returns {*}
 */
export function getHex(colorRgba){
    const r = Math.floor(colorRgba[0] * 255);
    const g = Math.floor(colorRgba[1] * 255);
    const b = Math.floor(colorRgba[2] * 255);
    return `#${((b | g << 8 | r << 16) | 1 << 24).toString(16).slice(1)}`;
}

/**
 * Creates a new color from hex string color representation.
 * @param hex
 * @returns {*}
 */
export function createFromHex(hex){
    return setFromHex(create(),hex);
}

//hsb

/**
 * Sets a colors r,g,b colors from hsb color representation.
 * @param color
 * @param hue
 * @param saturation
 * @param brightness
 * @returns {*}
 */
export function setFromHSB(color,hue,saturation,brightness){
    if(saturation === 0){
        color[0] = color[1] = color[2] = brightness;
        return color;
    }
    const hs = hue / 60;
    const i = Math.floor(hs);
    const f = hs - i;
    const p = brightness * (1.0 - saturation);
    const q = brightness * (1.0 - saturation * f);
    const t = brightness * (1.0 - saturation * (1.0 - f));

    let r,g,b;
    switch(i){
        case 0:
            r = brightness;
            g = t;
            b = p;
            break;
        case 1:
            r = q;
            g = brightness;
            b = p;
            break;
        case 2:
            r = p;
            g = brightness;
            b = t;
            break;
        case 3:
            r = p;
            g = q;
            b = brightness;
            break;
        case 4:
            r = t;
            g = p;
            b = brightness;
            break;
        default:
            r = brightness;
            g = p;
            b = q;
            break;
    }
    return set3(color,r,g,b);
}

/**
 * Creates a float color representation from hsb color representation.
 * @param hue
 * @param saturation
 * @param brightness
 * @returns {*}
 */
export function createFromHSB(hue,saturation,brightness){
    return setFromHSB(create(),hue,saturation,brightness);
}

/**
 * Sets r,g,b,a-values from hsba color representation.
 * @param color
 * @param hue
 * @param saturation
 * @param brightness
 * @param alpha
 * @returns {*}
 */
export function setFromHSBA(color,hue,saturation,brightness,alpha){
    color[3] = alpha;
    return setFromHSB(color,hue,saturation,brightness);
}

/**
 * Creates a float color representation from hsba color representation.
 * @param hue
 * @param saturation
 * @param brightness
 * @param alpha
 * @returns {*}
 */
export function createFromHSBA(hue,saturation,brightness,alpha){
    alpha = alpha === undefined ? 1.0 : alpha;
    return setFromHSBA(setAlpha(create(),alpha),hue,saturation,brightness);
}

/**
 *
 * @param color
 * @param out
 * @returns {*|Array}
 */
export function getHSB(color,out){
    out = out || [];
    const r = color[0];
    const g = color[1];
    const b = color[2];
    const cmax = Math.max(r,g,b);
    const cmin = Math.min(r,g,b);
    const brightness = cmax;
    let saturation;
    let hue;
    if(cmax !== 0){
        saturation = (cmax - cmin) / cmax;
    } else {
        saturation = 0;
    }
    if(saturation === 0){
        hue = 0;
    } else {
        const rc = (cmax - r) / (cmax - cmin);
        const gc = (cmax - g) / (cmax - cmin);
        const bc = (cmax - b) / (cmax - cmin);
        if(r === cmax){
            hue = bc - gc;
        } else if(g === cmax){
            hue = 2.0 + rc - bc;
        } else {
            hue = 4.0 + gc - rc;
        }
        hue = hue / 6.0;
        if(hue < 0.0){
            hue += 1.0;
        }
    }
    out[0] = hue * 360;
    out[1] = saturation;
    out[2] = brightness;
    return out;
}

/**
 *
 * @param colorRgb
 * @returns {*}
 */
export function getHue(colorRgb){
    return getHSB(colorRgb,TEMP_VEC3_0)[0];
}

/**
 *
 * @param colorRgb
 * @returns {*}
 */
export function getSaturation(colorRgb){
    return getHSB(colorRgb,TEMP_VEC3_0)[1];
}

/**
 *
 * @param colorRgb
 * @returns {*}
 */
export function getBrightness(colorRgb){
    return getHSB(colorRgb,TEMP_VEC3_0)[2];
}

//http://www.iquilezles.org/www/articles/palettes/palettes.htm
/**
 *
 * @param color
 * @param a
 * @param b
 * @param c
 * @param d
 * @param t
 * @returns {*}
 */
export function setFromCosPalette(color,a,b,c,d,t){
    color[0] = a[0] + b[0] * Math.cos(PI2 * (c[0] * t + d[0]));
    color[1] = a[1] + b[1] * Math.cos(PI2 * (c[1] * t + d[1]));
    color[2] = a[2] + b[2] * Math.cos(PI2 * (c[2] * t + d[2]));
    return color;
}

/**
 *
 * @param a
 * @param b
 * @param c
 * @param d
 * @param t
 * @returns {*}
 */
export function createFromCosPalette(a,b,c,d,t){
    return setFromCosPalette(create(),a,b,c,d,t);
}

//internal
function stepHSBComponent(color,index,dir,factor){
    factor = factor === undefined ? HSB_CHANGE_STEP : factor;
    const hsb = getHSB(color,TEMP_VEC3_0);
    hsb[index] = dir < 0 ? Math.max(0,hsb[index] - factor) : Math.min(1,hsb[index] + factor);
    return setFromHSB(color,hsb[0],hsb[1],hsb[2]);
}

/**
 * 
 * @param colorRgb
 * @param factor
 * @returns {*}
 */
export function darken(colorRgb,factor){
    return stepHSBComponent(colorRgb,2,-1,factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 */
export function darkened(colorRgb,factor){
    return darken(copy(colorRgb),factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 * @returns {*}
 */
export function brighten(colorRgb, factor){
    return stepHSBComponent(colorRgb,2,1,factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 */
export function brightened(colorRgb, factor){
    return brighten(copy(colorRgb),factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 * @returns {*}
 */
export function saturate(colorRgb,factor){
    return stepHSBComponent(colorRgb,1,1,factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 */
export function saturated(colorRgb,factor){
    return saturate(copy(colorRgb),factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 * @returns {*}
 */
export function desaturate(colorRgb,factor){
    return stepHSBComponent(colorRgb,1,-1,factor);
}

/**
 *
 * @param colorRgb
 * @param factor
 */
export function desaturated(colorRgb,factor){
    return desaturate(copy(colorRgb),factor);
}

/*----------------------------------------------------------------------------------------------------------------*/
// lerp
/*----------------------------------------------------------------------------------------------------------------*/

//internal

function multiLerpInfo(length,t,out){
    const len_1  = length - 1;
    const index  = Math.floor(len_1 * t);
    const next   = Math.min(index + 1, len_1);
    const sector = 1 / len_1;
    const n = (t - index / len_1) / sector;

    out[0] = index;
    out[1] = next;
    out[2] = n;

    return out;
}

function multiLerpColorInfo(color,colors,t,out){
    TEMP_ARR_0.length = 0;
    TEMP_ARR_0[0] = color;
    for(let i = 0; i < colors.length;++i){
        TEMP_ARR_0[i+1] = colors[i];
    }
    const info = multiLerpInfo(TEMP_ARR_0.length,t,TEMP_VEC3_0);

    out[0] = TEMP_ARR_0[info[0]];
    out[1] = TEMP_ARR_0[info[1]];
    out[2] = info[2];

    return out;
}

//lerp rgba

/**
 * Linear interpolates r,g,b-values with other color r,g,b-values;
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpRGBA(colora,colorb,t){
    lerpRGB(colora,colorb,t);
    colora[3] = colora[3] * (1.0 - t) + colorb[3] * t;
    return colora;
}

/**
 * Returns a copy of the lerped input color.
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpedRGBA(colora,colorb,t){
    return lerpRGBA(copy(colora),colorb,t);
}

/**
 * Linear interpolates r,g,b-values with a set of colors.
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpRGBA(color,colors,t){
    const info = multiLerpColorInfo(color,colors,t,TEMP_VEC3_0);
    const colora = info[0];
    const colorb = info[1];
    const n = info[2];

    return lerpRGBA(set(color,colora),colorb,n);
}

/**
 * Returns a copy of the lerped input color.
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpedRGBA(color,colors,t){
    return multiLerpRGBA(copy(color),colors,t);
}

/**
 * @param colors
 * @param t
 * @returns {*}
 */
export function createFromMultiLerpedRGBA(colors,t){
    TEMP_ARR_0.length = 0;
    for(let i = 1; i < colors.length; ++i){
        TEMP_ARR_0[i-1] = colors[i];
    }
    return multiLerpedRGBA(colors[0],TEMP_ARR_0,t);
}

//lerp rgb

/**
 *
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpRGB(colora,colorb,t){
    const _1_t = 1.0 - t;
    colora[0] = colora[0] * _1_t + colorb[0] * t;
    colora[1] = colora[1] * _1_t + colorb[1] * t;
    colora[2] = colora[2] * _1_t + colorb[2] * t;
    return colora;
}

/**
 *
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpedRGB(colora,colorb,t){
    return lerpRGB(copy(colora),colorb,t);
}

/**
 *
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpRGB(color,colors,t){
    const info = multiLerpColorInfo(color,colors,t,TEMP_VEC3_0);
    const colora = info[0];
    const colorb = info[1];
    const n = info[2];

    return lerpRGB(set(color,colora),colorb,n);
}

/**
 *
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpedRGB(color,colors,t){
    return multiLerpRGB(copy(color),colors, t);
}

/**
 *
 * @param colors
 * @param t
 * @returns {*}
 */
export function createFromMultiLerpedRGB(colors,t){
    TEMP_ARR_0.length = 0;
    for(let i = 1; i < colors.length; ++i){
        TEMP_ARR_0[i-1] = colors[i];
    }
    return multiLerpedRGB(colors[0],TEMP_ARR_0,t);
}

//lerp rgba gamma

/**
 *
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpRGBAGamma(colora,colorb,t){
    lerpRGBGamma(colora,colorb,t);
    colora[3] = colora[3] * (1.0 - t) + colorb[3] * t;
    return colora;
}

/**
 *
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpedRGBAGamma(colora,colorb,t){
    return lerpRGBAGamma(copy(colora),colorb,t);
}

/**
 *
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpRGBAGamma(color,colors,t){
    const info = multiLerpColorInfo(color,colors,t,TEMP_VEC3_0);
    const colora = info[0];
    const colorb = info[1];
    const n = info[2];

    return lerpRGBAGamma(copy(colora),colorb,n);
}

/**
 *
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpedRGBAGamma(color,colors,t){
    return multiLerpRGBAGamma(copy(color),colors,t);
}

/**
 *
 * @param colors
 * @param t
 * @returns {*}
 */
export function createFromMultiLerpedRGBAGamma(colors,t){
    TEMP_ARR_0.length = 0;
    for(let i = 1; i < colors.length; ++i){
        TEMP_ARR_0[i-1] = colors[i];
    }
    return multiLerpedRGBAGamma(colors[0],TEMP_ARR_0,t);
}

//lerp rgb gamma

/**
 *
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpRGBGamma(colora,colorb,t){
    const _1_t = 1.0 - t;
    const ral = Math.pow(colora[0],GAMMA);
    const gal = Math.pow(colora[1],GAMMA);
    const bal = Math.pow(colora[2],GAMMA);
    const rbl = Math.pow(colorb[0],GAMMA);
    const gbl = Math.pow(colorb[1],GAMMA);
    const bbl = Math.pow(colorb[2],GAMMA);
    colora[0] = Math.pow(ral * _1_t + rbl * t, 1.0/GAMMA);
    colora[1] = Math.pow(gal * _1_t + gbl * t, 1.0/GAMMA);
    colora[2] = Math.pow(bal * _1_t + bbl * t, 1.0/GAMMA);
    return colora;
}

/**
 *
 * @param colora
 * @param colorb
 * @param t
 * @returns {*}
 */
export function lerpedRGBGamma(colora,colorb,t){
    return lerpRGBGamma(copy(colora),colorb,t);
}

/**
 *
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpRGBGamma(color,colors,t){
    const info = multiLerpColorInfo(color,colors,t,TEMP_VEC3_0);
    const colora = info[0];
    const colorb = info[1];
    const n = info[2];

    return lerpRGBGamma(set(color,colora),colorb,n);
}

/**
 *
 * @param color
 * @param colors
 * @param t
 * @returns {*}
 */
export function multiLerpedRGBGamma(color,colors,t){
    return multiLerpRGBGamma(copy(color),colors,t);
}

/**
 *
 * @param colors
 * @param t
 * @returns {*}
 */
export function createFromMultiLerpedRGBGamma(colors,t){
    TEMP_ARR_0.length = 0;
    for(let i = 1; i < colors.length; ++i){
        TEMP_ARR_0[i-1] = colors[i];
    }
    return multiLerpedRGBGamma(colors[0],TEMP_ARR_0,t);
}